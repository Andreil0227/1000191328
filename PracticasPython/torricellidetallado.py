# -*- coding: utf-8 -*-
"""TorricelliDetallado.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RVkHnoPbI9IZnYSz4IjcQ2Xy3LPPIlXZ
"""

# Programa de ley de torricelli para problemas definidos y tener relación altura, liquido y velocidad

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

# Parámetros del problema
h0 = 2.0          # Altura inicial [m]
a_orificio = 0.0008  # Área del orificio [m²]
k = 0.65          # Coeficiente de descarga
g = 9.81          # Gravedad [m/s²]

# Función que define el área transversal variable A(h)
def A(h):
    return np.where(h > 0.5, 1.2, 0.8)  # 1.2 m² arriba de 0.5m, 0.8 m² abajo

# Ecuación diferencial de Torricelli con A(h) variable
def dh_dt(t, h):
    # Asegurarse de que h no sea negativo en sqrt
    h_clipped = np.maximum(0, h)
    return -(k * a_orificio * np.sqrt(2 * g * h_clipped)) / A(h_clipped)

# Tiempo de integración (0 a 5000 segundos - aumentado para asegurar vaciado)
t_span = (0, 5000)
t_eval = np.linspace(0, 5000, 5000) # Más puntos para mayor resolución

# Resolver la EDO
sol = solve_ivp(dh_dt, t_span, [h0], t_eval=t_eval, method='RK45')

# Extraer resultados
t = sol.t
h = sol.y[0]

# Calcular la velocidad de vaciado (dh/dt) en cada punto
dhdt = dh_dt(t, h)

# Crear gráficos
plt.figure(figsize=(12, 6))

# Gráfico 1: Altura vs Tiempo
plt.subplot(1, 2, 1)
plt.plot(t, h, 'b-', linewidth=2)
plt.axhline(y=0.5, color='r', linestyle='--', label='Cambio en A(h)')
plt.axhline(y=0, color='k', linestyle=':', label='h = 0') # Agregar línea para h=0
plt.title('Altura del líquido vs Tiempo')
plt.xlabel('Tiempo (s)')
plt.ylabel('Altura (m)')
plt.grid(True)
plt.legend()

# Gráfico 2: Velocidad de vaciado vs Altura
plt.subplot(1, 2, 2)
# Solo graficar donde la altura es positiva para evitar NaN/inf en dhdt cerca de h=0
valid_indices = h > 1e-6 # Usar un pequeño umbral para evitar problemas numéricos cerca de cero
plt.plot(h[valid_indices], -dhdt[valid_indices], 'g-', linewidth=2)  # -dh/dt para que sea positiva
plt.axvline(x=0.5, color='r', linestyle='--', label='Cambio en A(h)')
plt.title('Velocidad de vaciado vs Altura')
plt.xlabel('Altura (m)')
plt.ylabel('Velocidad de vaciado (m/s)')
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.show()

# Mostrar tiempos clave
# Encontrar el primer índice donde h <= 0.5
idx_05m_candidates = np.where(h <= 0.5)[0]
if idx_05m_candidates.size > 0:
    idx_05m = idx_05m_candidates[0]
    t_05m = t[idx_05m]
    print(f"Tiempo para llegar a 0.5m: {t_05m:.1f} s")
else:
    print("El nivel nunca llegó a 0.5m durante la simulación.")
    idx_05m = None # Asignar None si no se encuentra

# Encontrar el primer índice donde h <= 0.01 (aproximación al vaciado total)
idx_empty_candidates = np.where(h <= 0.01)[0]
if idx_empty_candidates.size > 0:
    idx_total = idx_empty_candidates[0]
    t_total = t[idx_total]
    print(f"Tiempo total de vaciado (h <= 0.01): {t_total:.1f} s")
else:
    print("El tanque no se vació a 0.01m durante la simulación.")
    t_total = t[-1] # Usar el tiempo final de la simulación si no se vació
    print(f"Altura final después de {t_total:.1f} s: {h[-1]:.4f} m")


print(f"Velocidad inicial: {-dhdt[0]:.4f} m/s")
# Mostrar velocidad a 0.5m solo si se encontró el índice
if idx_05m is not None:
     print(f"Velocidad a 0.5m: {-dhdt[idx_05m]:.4f} m/s")